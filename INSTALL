#!/usr/bin/env bash

function main {
	# Prompt for info
	read -p $'Username to ssh into on Apple machine:\n' USERNAME
	read -p $'IP address of Apple machine:\n' IPADDR

	# Make this input later.
	DBNAME="smsTest.db"

	# Check that USERNAME@IPADDR is reachable.
	ssh -q "${USERNAME}"@"${IPADDR}" exit
	SSHSUCCESS=$?
	if [ $SSHSUCCESS -ne 0 ]
	then
	# If it is not reachable, ask if you want to continue.
		echo "Failed to login as ${USERNAME} on the machine ${IPADDR}"
	else
	# If it is, continue with installation.
		echo "Succeeded logging in as ${USERNAME} on the machine ${IPADDR}"
		echo "Creating a database at ${DBNAME} for incoming messages..."
		create_database
		echo "Done creating ${DBNAME}."
		get_homedir_expansion
		find_message_db
		install_scripts
		update_macbook_chatdb
		create_incoming_message_db
		create_remote_config
		create_secrets_json
	fi
}

function create_secrets_json {
	cat << END_DOCUMENT > secretsTest.json
{
	"user": "${USERNAME}",
	"ip": "${IPADDR}",
	"scriptPath": "${HOMEDIR_EXPANSION}/Applications/macbook/addOutgoing.py",
	"retrieveScriptPath": "${HOMEDIR_EXPANSION}/Applications/macbook/getMessages.py"
}
END_DOCUMENT
}

function create_remote_config {
	ssh "${USERNAME}"@"${IPADDR}" /bin/bash << END_DOCUMENT
		cat << END_CAT > "${HOMEDIR_EXPANSION}"/Applications/macbook/config.json
{
        "queueLocation": "${HOMEDIR_EXPANSION}/Library/Messages2/msgqueue.db",
        "chatLocation": "${HOMEDIR_EXPANSION}/Library/Messages2/chat.db"
}

END_DOCUMENT
}

function create_incoming_message_db {
	ssh "${USERNAME}"@"${IPADDR}" /bin/bash << END_DOCUMENT
		sqlite3 "${HOMEDIR_EXPANSION}"/Library/Messages2/msgqueue.db << END_SQL
			CREATE TABLE IF NOT EXISTS outgoing ( ROWID INTEGER PRIMARY KEY AUTOINCREMENT, text text, chatId INTEGER, assocGUID text, assocType INTEGER, messageCode INTEGER );
END_SQL
	exit \$?
END_DOCUMENT

}

function update_macbook_chatdb {
	ssh "${USERNAME}"@"${IPADDR}" /bin/bash << END_DOCUMENT
		sqlite3 "${HOMEDIR_EXPANSION}"/Library/Messages2/chat.db << END_SQL
			CREATE TABLE IF NOT EXISTS message_update_date_join (message_id INTEGER REFERENCES message (ROWID) ON DELETE CASCADE, message_update_date INTEGER DEFAULT 0, PRIMARY KEY (message_id, message_update_date));
			CREATE TRIGGER IF NOT EXISTS insert_last_update_date AFTER INSERT ON message BEGIN INSERT INTO message_update_date_join (message_id, message_update_date) VALUES ( NEW.ROWID, strftime('%s','now') ); END;
			CREATE TRIGGER IF NOT EXISTS update_last_update_date AFTER UPDATE ON message BEGIN UPDATE message_update_date_join SET message_update_date = strftime('%s','now') WHERE message_id = OLD.ROWID; END;
END_SQL
	exit \$?
END_DOCUMENT

}

function install_scripts {
	scp -q -r $(pwd)/remoteCode/macbook "${USERNAME}"@"${IPADDR}":~/Applications
	OUTPUT=$?
	if [ $OUTPUT -ne 0 ]
	then
		echo "Error encountered transferring files to ${USERNAME}@${IPADDR}."
	else
		echo "Transferred remote code to macbook."
	fi
}

function find_message_db {
	ssh "${USERNAME}"@"${IPADDR}" /bin/bash << END_DOCUMENT
test -f ${HOMEDIR_EXPANSION}/Library/Messages/chat.db
exit \$?
END_DOCUMENT

	OUTPUT=$?

	if [ $OUTPUT -ne 0 ]
	then
		echo "Could not find message database."
	else
		CHATDB_LOCATION="${HOMEDIR_EXPANSION}/Library/Messages/chat.db"
		echo "Found chat.db at ${CHATDB_LOCATION}."
	fi
}

function get_homedir_expansion {
	HOMEDIR_EXPANSION=$(ssh "${USERNAME}"@"${IPADDR}" echo '$HOME';)
}

function create_database {
	sqlite3 ./smsTest.db << END_DOCUMENT
CREATE TABLE IF NOT EXISTS _SqliteDatabaseProperties (key TEXT, value TEXT, UNIQUE(key));
CREATE TABLE IF NOT EXISTS handle (ROWID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, id TEXT NOT NULL, country TEXT, service TEXT NOT NULL, uncanonicalized_id TEXT, UNIQUE (id, service) );
CREATE TABLE IF NOT EXISTS deleted_messages (ROWID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, guid TEXT NOT NULL);
CREATE TABLE IF NOT EXISTS chat_message_join (chat_id INTEGER REFERENCES chat (ROWID) ON DELETE CASCADE, message_id INTEGER REFERENCES message (ROWID) ON DELETE CASCADE, PRIMARY KEY (chat_id, message_id));
CREATE TABLE IF NOT EXISTS chat_handle_join (chat_id INTEGER REFERENCES chat (ROWID) ON DELETE CASCADE, handle_id INTEGER REFERENCES handle (ROWID) ON DELETE CASCADE, UNIQUE(chat_id, handle_id));
CREATE TABLE IF NOT EXISTS message (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, guid TEXT UNIQUE NOT NULL, text TEXT, replace INTEGER DEFAULT 0, service_center TEXT, handle_id INTEGER DEFAULT 0, subject TEXT, country TEXT, attributedBody BLOB, version INTEGER DEFAULT 0, type INTEGER DEFAULT 0, service TEXT, account TEXT, account_guid TEXT, error INTEGER DEFAULT 0, date INTEGER, date_read INTEGER, date_delivered INTEGER, is_delivered INTEGER DEFAULT 0, is_finished INTEGER DEFAULT 0, is_emote INTEGER DEFAULT 0, is_from_me INTEGER DEFAULT 0, is_empty INTEGER DEFAULT 0, is_delayed INTEGER DEFAULT 0, is_auto_reply INTEGER DEFAULT 0, is_prepared INTEGER DEFAULT 0, is_read INTEGER DEFAULT 0, is_system_message INTEGER DEFAULT 0, is_sent INTEGER DEFAULT 0, has_dd_results INTEGER DEFAULT 0, is_service_message INTEGER DEFAULT 0, is_forward INTEGER DEFAULT 0, was_downgraded INTEGER DEFAULT 0, is_archive INTEGER DEFAULT 0, cache_has_attachments INTEGER DEFAULT 0, cache_roomnames TEXT, was_data_detected INTEGER DEFAULT 0, was_deduplicated INTEGER DEFAULT 0, is_audio_message INTEGER DEFAULT 0, is_played INTEGER DEFAULT 0, date_played INTEGER, item_type INTEGER DEFAULT 0, other_handle INTEGER DEFAULT 0, group_title TEXT, group_action_type INTEGER DEFAULT 0, share_status INTEGER DEFAULT 0, share_direction INTEGER DEFAULT 0, is_expirable INTEGER DEFAULT 0, expire_state INTEGER DEFAULT 0, message_action_type INTEGER DEFAULT 0, message_source INTEGER DEFAULT 0, associated_message_guid TEXT, associated_message_type INTEGER DEFAULT 0, balloon_bundle_id TEXT, payload_data BLOB, expressive_send_style_id TEXT, associated_message_range_location INTEGER DEFAULT 0, associated_message_range_length INTEGER DEFAULT 0, time_expressive_send_played INTEGER, message_summary_info BLOB);
CREATE TABLE IF NOT EXISTS chat (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, guid TEXT UNIQUE NOT NULL, style INTEGER, state INTEGER, account_id TEXT, properties BLOB, chat_identifier TEXT, service_name TEXT, room_name TEXT, account_login TEXT, is_archived INTEGER DEFAULT 0, last_addressed_handle TEXT, display_name TEXT, group_id TEXT, is_filtered INTEGER, successful_query INTEGER);
CREATE INDEX IF NOT EXISTS message_idx_is_read ON message(is_read, is_from_me, is_finished);
CREATE INDEX IF NOT EXISTS message_idx_date ON message(date);
CREATE INDEX IF NOT EXISTS chat_idx_chat_identifier_service_name ON chat(chat_identifier, service_name);
CREATE INDEX IF NOT EXISTS chat_idx_chat_identifier ON chat(chat_identifier);
CREATE INDEX IF NOT EXISTS message_idx_failed ON message(is_finished, is_from_me, error);
CREATE INDEX IF NOT EXISTS message_idx_was_downgraded ON message(was_downgraded);
CREATE INDEX IF NOT EXISTS chat_idx_chat_room_name_service_name ON chat(room_name, service_name);
CREATE INDEX IF NOT EXISTS chat_message_join_idx_message_id ON chat_message_join(message_id, chat_id);
CREATE INDEX IF NOT EXISTS chat_handle_join_idx_handle_id ON chat_handle_join(handle_id);
CREATE INDEX IF NOT EXISTS message_idx_handle ON message(handle_id, date);
CREATE INDEX IF NOT EXISTS message_idx_handle_id ON message(handle_id);
CREATE INDEX IF NOT EXISTS chat_message_join_idx_chat_id ON chat_message_join(chat_id);
CREATE INDEX IF NOT EXISTS message_idx_other_handle ON message(other_handle);
CREATE INDEX IF NOT EXISTS message_idx_expire_state ON message(expire_state);
CREATE INDEX IF NOT EXISTS chat_message_join_idx_message_id_only ON chat_message_join(message_id);
CREATE INDEX IF NOT EXISTS message_idx_associated_message ON message(associated_message_guid);
CREATE INDEX IF NOT EXISTS chat_idx_is_archived ON chat(is_archived);
CREATE TRIGGER IF NOT EXISTS after_delete_on_chat AFTER DELETE ON chat BEGIN DELETE FROM chat_message_join WHERE chat_id = OLD.ROWID; END;
CREATE TRIGGER IF NOT EXISTS delete_associated_messages_after_delete_on_message AFTER DELETE ON message BEGIN DELETE FROM message WHERE (OLD.associated_message_guid IS NULL AND associated_message_guid IS NOT NULL AND guid = OLD.associated_message_guid); END;
CREATE TRIGGER IF NOT EXISTS add_to_deleted_messages AFTER DELETE ON message BEGIN     INSERT INTO deleted_messages (guid) VALUES (OLD.guid); END;
CREATE TRIGGER IF NOT EXISTS after_delete_on_chat_message_join AFTER DELETE ON chat_message_join BEGIN UPDATE message SET cache_roomnames = (SELECT group_concat(c.room_name) FROM chat c INNER JOIN chat_message_join j ON c.ROWID = j.chat_id WHERE j.message_id = OLD.message_id) WHERE message.ROWID = OLD.message_id; DELETE FROM message WHERE message.ROWID = OLD.message_id AND OLD.message_id NOT IN (SELECT chat_message_join.message_id from chat_message_join WHERE chat_message_join.message_id = OLD.message_id LIMIT 1); END;
CREATE TRIGGER IF NOT EXISTS after_delete_on_chat_handle_join AFTER DELETE ON chat_handle_join BEGIN DELETE FROM handle WHERE handle.ROWID = OLD.handle_id AND (SELECT 1 from chat_handle_join WHERE handle_id = OLD.handle_id LIMIT 1) IS NULL AND (SELECT 1 from message WHERE handle_id = OLD.handle_id LIMIT 1) IS NULL AND (SELECT 1 from message WHERE other_handle = OLD.handle_id LIMIT 1) IS NULL; END;
CREATE TRIGGER IF NOT EXISTS after_delete_on_message AFTER DELETE ON message BEGIN DELETE FROM handle WHERE handle.ROWID = OLD.handle_id AND (SELECT 1 from chat_handle_join WHERE handle_id = OLD.handle_id LIMIT 1) IS NULL AND (SELECT 1 from message WHERE handle_id = OLD.handle_id LIMIT 1) IS NULL AND (SELECT 1 from message WHERE other_handle = OLD.handle_id LIMIT 1) IS NULL; END;
CREATE TRIGGER IF NOT EXISTS after_insert_on_chat_message_join  AFTER INSERT ON chat_message_join BEGIN UPDATE message SET cache_roomnames = (SELECT group_concat(c.room_name) FROM chat c INNER JOIN chat_message_join j ON c.ROWID = j.chat_id WHERE j.message_id = NEW.message_id) WHERE message.ROWID = NEW.message_id; END;
CREATE TABLE IF NOT EXISTS attachment (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, guid TEXT UNIQUE NOT NULL, created_date INTEGER DEFAULT 0, start_date INTEGER DEFAULT 0, filename TEXT, uti TEXT, mime_type TEXT, transfer_state INTEGER DEFAULT 0, is_outgoing INTEGER DEFAULT 0, user_info BLOB, transfer_name TEXT, total_bytes INTEGER DEFAULT 0, is_sticker INTEGER DEFAULT 0, sticker_user_info BLOB, attribution_info BLOB, hide_attachment INTEGER DEFAULT 0);
CREATE TRIGGER IF NOT EXISTS before_delete_on_attachment BEFORE DELETE ON attachment BEGIN   SELECT before_delete_attachment_path(OLD.ROWID, OLD.guid); END;
CREATE TRIGGER IF NOT EXISTS after_delete_on_attachment AFTER DELETE ON attachment BEGIN   SELECT delete_attachment_path(OLD.filename); END;
CREATE TABLE IF NOT EXISTS message_attachment_join (message_id INTEGER REFERENCES message (ROWID) ON DELETE CASCADE, attachment_id INTEGER REFERENCES attachment (ROWID) ON DELETE CASCADE, UNIQUE(message_id, attachment_id));
CREATE INDEX IF NOT EXISTS message_attachment_join_idx_message_id ON message_attachment_join(message_id);
CREATE INDEX IF NOT EXISTS message_attachment_join_idx_attachment_id ON message_attachment_join(attachment_id);
CREATE TRIGGER IF NOT EXISTS after_delete_on_message_attachment_join AFTER DELETE ON message_attachment_join BEGIN     DELETE FROM attachment         WHERE attachment.ROWID = OLD.attachment_id     AND         (SELECT 1 from message_attachment_join WHERE attachment_id = OLD.attachment_id LIMIT 1) IS NULL; END;
CREATE TRIGGER IF NOT EXISTS after_insert_on_message_attachment_join AFTER INSERT ON message_attachment_join BEGIN     UPDATE message       SET cache_has_attachments = 1     WHERE       message.ROWID = NEW.message_id; END;
CREATE TABLE IF NOT EXISTS message_update_date_join (message_id INTEGER REFERENCES message (ROWID) ON DELETE CASCADE, message_update_date INTEGER DEFAULT 0, PRIMARY KEY (message_id, message_update_date));
CREATE TRIGGER IF NOT EXISTS insert_last_update_date AFTER INSERT ON message BEGIN INSERT INTO message_update_date_join (message_id, message_update_date) VALUES ( NEW.ROWID, strftime('%s','now') ); END;
CREATE TRIGGER IF NOT EXISTS update_last_update_date AFTER UPDATE ON message BEGIN UPDATE message_update_date_join SET message_update_date = strftime('%s','now') WHERE message_id = OLD.ROWID; END;
END_DOCUMENT
}

main
